
(* Proof of Bellman-Ford algorithm *)

theory Graph

  use export int.Int
  use export set.Fset

  type vertex
  constant vertices : set vertex
  constant s : vertex
  function succ vertex : set vertex
  function weight vertex vertex : int

  axiom s_in_graph: mem s vertices

  axiom succ1:
    forall x: vertex. mem x vertices -> subset (succ x) vertices

  inductive path (v1 v2: vertex) (n: int) (d: int) =
    | path_empty:
        forall v: vertex. path v v 0 0
    | path_succ:
        forall v1 v2 v3: vertex, n d: int.
        path v1 v2 n d -> mem v3 (succ v2) ->
        path v1 v3 (n + weight v2 v3) (d + 1)

  predicate shortest_path (v1 v2: vertex) (n: int) (d: int) =
    (path v1 v2 n d) /\
    (forall m d: int. m < n -> not (path v1 v2 m d))

  inductive reachable (v1 v2: vertex) (d: int) =
    | reach_empty:
        forall v: vertex. reachable v v 0
    | reach_succ:
        forall v1 v2 v3: vertex, d: int.
        reachable v1 v2 d -> mem v3 (succ v2) ->
        reachable v1 v3 (d + 1)

  predicate no_path (v1 v2: vertex) =
    forall d: int. not (reachable d)

  (* Negative cycle existence *)
  predicate negcycle () =
    exists v: vertex. (mem v vertices /\
    (exists n: int. n < 0 /\ path v v n))

  (* The negation of [negcycle].
     BTW, is it truely negative? maybe not... *)
  predicate non_negcycle () =
    forall v: vertex. mem v vertices ->
    not (exists n: int. n < 0 /\ path v v n)

  (* Firstly, we don't provide non-negative edge *)
  axiom nonneg1:
    forall x y: vertex. weight x y >= 0

  (* Late we will relax the condition *)
  (*** axiom nonneg2: non_negcycle () ***)

end 

theory Distance

  use import int.Int

  type dist = Finite int | Infinite

  function (++) (x: dist) (y: dist) : dist =
    match x with
      | Infinite -> Infinite
      | Finite x ->
        match y with
          | Infinite -> Infinite
          | Finite y -> Finite (x + y)
        end
    end

  predicate (<<) (x y: dist) =
    match x with
      | Infinite -> false
      | Finite x ->
        match y with
          | Infinite -> true
          | Finite y -> x < y
        end
    end

  predicate ge (x y: dist) =
    match x with
      | Infinite -> true
      | Finite x ->
        match y with
          | Infinite -> false
          | Finite y -> x >= y
        end
    end

  clone export comparison.MinMax with type t = dist, predicate ge = ge

end

theory FSetTake

  use export set.Fset

  function take (s:set 'a) : 'a

  axiom take_def:
    forall x : set 'a. not (is_empty x) ->
    mem (take x) x

end

(* a bag is simply a reference containing a finite set *)
module Bag

  use export FSetTake
  use export module ref.Ref

  type bag 'a = ref (set 'a)

  let is_empty (b: bag 'a) =
    {} is_empty !b { result=True <-> is_empty !b }

  (*
  val push (x: 'a) (b: bag 'a) :
    {} unit writes b { !b = add x (old !b) }
  *)

  let pop (b: bag 'a) =
    { not (is_empty !b) }
    let x = take !b in
    b := remove x !b;
    x
    { mem result (old !b) /\ !b = remove result (old !b) }

end

module BellmanFord

  use import int.MinMax
  use import map.Map
  use import module ref.Ref
  use import Graph
  use import Distance
  use module Bag

  type distmap = map vertex dist
  type option 'a = Nil | Vertex 'a
  type parentmap = map vertex (option vertex)
  type info = (distmap, parentmap)

  function initialize_single_source (s: vertex) : info =
    ((const Infinite)[s <- Finite 0], (const Nil))

  predicate exact (i: info) =
    forall v: vertex. shortest_path
      true

  predicate paths (m: info) =
    true (*
    forall v: vertex. mem v vertices ->
    match m[v] with
      | Finite n -> path s v n (* path, not shortest_path *)
      | Infinite -> true
    end *)

  let relax (info: ref info) (u: vertex) (v: vertex) =
    { mem u vertices /\ mem v (succ u) /\ paths !info }
    let (dist, parent) = !info in
    let new_d = dist[u] ++ Finite (weight u v) in
    if new_d << dist[v] then begin
      info := (dist[v <- new_d], parent[v <- Vertex u])
    end
    { paths !m /\
      forall x: vertex. (x <> v ->
	get !m x = get (old !m) x) }

  exception NegativeCycle (* list vertex *)

  let bellman_ford () =
    { }

    let m = ref (initialize_single_source s) in
    assert { paths !m };

    for i = 1 to cardinal vertices - 1 do
      invariant { paths !m
	(* Less than i-depth shortest tree nodes have exact distance.
           Infinity distance > no reachable in i-depth	*) }

      let us = ref vertices in
      while not (Bag.is_empty us) do
        invariant { subset !us vertices /\ paths !m }
        variant { cardinal !us }

        let u = Bag.pop us in
        let vs = ref (succ u) in
        while not (Bag.is_empty vs) do
          invariant { subset !vs (succ u) /\ paths !m }
          variant { cardinal !vs }

          let v = Bag.pop vs in
          relax m u v
        done
      done
    done;

    let us = ref vertices in
    while not (Bag.is_empty us) do
      variant { cardinal !us }
      let u = Bag.pop us in
    
      let vs = ref (succ u) in
      while not (Bag.is_empty vs) do
        variant { cardinal !vs }
        let v = Bag.pop vs in

        if (get !m v) <<
          ((get !m u) ++ (Finite (weight u v))) then
          raise NegativeCycle
      done
    done;

    !m

    { paths result }
    | NegativeCycle -> { }

end

(*
Local Variables:
compile-command: "why3ide bf.mlw"
End:
*)
