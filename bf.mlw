
(* Proof of Bellman-Ford algorithm *)

theory Graph

  use export int.Int
  use export set.Fset

  type vertex
  constant vertices : set vertex
  constant edges: set (vertex, vertex)
  constant s : vertex
  function weight vertex vertex : int

  axiom s_in_graph: mem s vertices
  lemma vertices_cardinal_pos: cardinal vertices > 0

  axiom edges_def:
    forall x y: vertex. mem (x, y) edges ->
    (mem x vertices /\ mem y vertices)

  inductive path (v1 v2: vertex) (n d: int) =
    | path_empty:
        forall v: vertex. path v v 0 0
    | path_succ:
        forall v1 v2 v3: vertex, n d: int. path v1 v2 n d ->
        mem (v2, v3) edges -> path v1 v3 (n + (weight v2 v3)) (d + 1)

  lemma path_depth_nonneg:
    forall v1 v2: vertex, n d: int.
    path v1 v2 n d -> d >= 0

  lemma path_in_vertices:
     forall v1 v2: vertex, n d: int.
     mem v1 vertices -> path v1 v2 n d -> mem v2 vertices

  lemma path_depth_empty:
    forall v1 v2: vertex, n d: int.
    path v1 v2 n 0 -> v1 = v2 /\ n = 0

  lemma path_pred_existence:
    forall v1 v3: vertex, n d: int. d >= 0 -> path v1 v3 n (d + 1) ->
    exists v2: vertex. mem (v2, v3) edges /\
    path v1 v2 (n - (weight v2 v3)) d

  predicate shortest_path (v1 v2: vertex) (n d: int) =
    (path v1 v2 n d) /\
    (forall n' d': int. n' < n -> not (path v1 v2 n' d'))

  lemma shortest_path_empty:
    forall v: vertex. mem v vertices ->
    (forall n d: int. n < 0 -> not (path v v n d)) ->
    shortest_path v v 0 0

(*
  I don't think this can be proved right now.
  lemma shortest_path_pred:
    forall v: vertex. mem v vertices ->
    forall n d: int. shortest_path s v n d ->
    exists u: vertex. mem (u, v) edges /\
    shortest_path s u (n - weight u v) (d - 1)
*)
  predicate no_path (v1 v2: vertex) =
    forall n d: int. not (path v1 v2 n d)

  lemma no_path_not_same:
    forall v: vertex. not (no_path v v)

  lemma path_trans:
    forall v1 v2 v3: vertex, n1 n2 d1 d2: int.
    path v1 v2 n1 d1 -> path v2 v3 n2 d2 ->
    path v1 v3 (n1 + n2) (d1 + d2)

  lemma reach_less_than_n:
    forall v1 v2: vertex. mem v1 vertices ->
    forall d n: int. path v1 v2 n d ->
    exists d' n': int. d' < cardinal vertices /\ path v1 v2 n' d'

  lemma reach_most_n:
    forall v1 v2: vertex.
    mem v1 vertices /\ mem v2 vertices ->
    (forall n d: int. 0 <= d < cardinal vertices ->
      not (path v1 v2 n d)) ->
    no_path v1 v2

  predicate negcycle =
    exists v: vertex. mem v vertices /\
    exists n d: int. n < 0 /\ path v v n d

  (*** Later we will eliminate this assumption ***)
  axiom ignore_negcycle: negcycle -> false

end

theory Distance

  use import int.Int

  type dist = Finite int | Infinite

  function (++) (x: dist) (y: dist) : dist =
    match x with
      | Infinite -> Infinite
      | Finite x ->
        match y with
          | Infinite -> Infinite
          | Finite y -> Finite (x + y)
        end
    end

  predicate (<<) (x y: dist) =
    match x with
      | Infinite -> false
      | Finite x ->
        match y with
          | Infinite -> true
          | Finite y -> x < y
        end
    end

  predicate (>>=) (x y: dist) =
    match x with
      | Infinite -> true
      | Finite x ->
        match y with
          | Infinite -> false
          | Finite y -> x >= y
        end
    end

  clone export comparison.MinMax with type t = dist, predicate ge = (>>=)

end

theory FSetEx

  use export set.Fset

  function take (s:set 'a) : 'a

  axiom take_def:
    forall x : set 'a. not (is_empty x) ->
    mem (take x) x

  lemma set_empty:
    forall a: set 'a. is_empty a <-> a = empty

  lemma set_union_exchange:
    forall a b: set 'a. union a b = union b a

  lemma set_inter_exchange:
    forall a b: set 'a. inter a b = inter b a

  lemma set_inter_choice:
    forall a b: set 'a, e: 'a. inter a b = empty ->
    mem e a -> not (mem e b)

  lemma set_preserve_union:
    forall a b: set 'a, e: 'a. mem e a ->
    union (remove e a) (add e b) = union a b

  lemma set_preserve_inter:
    forall a b: set 'a, e: 'a. mem e a /\ not (mem e b) ->
    inter (remove e a) (add e b) = inter a b

  lemma set_empty_union:
    forall a: set 'a. union a empty = a

  lemma set_empty_inter:
    forall a: set 'a. inter a empty = empty

end

(* a bag is simply a reference containing a finite set *)
module Bag

  use export FSetEx
  use export module ref.Ref

  type bag 'a = ref (set 'a)

  let is_empty (b: bag 'a) =
    {} is_empty !b { result=True <-> is_empty !b }

  (*
  val push (x: 'a) (b: bag 'a) :
    {} unit writes b { !b = add x (old !b) }
  *)

  let pop (b: bag 'a) =
    { not (is_empty !b) }
    let x = take !b in
    b := remove x !b;
    x
    { mem result (old !b) /\ !b = remove result (old !b) }

end

module BellmanFord

  use import int.MinMax
  use import map.Map
  use import module ref.Ref
  use import Graph
  use import Distance
  use FSetEx
  use module Bag

  type distmap = map vertex dist

  function initialize_single_source (s: vertex) : distmap =
    (const Infinite)[s <- Finite 0]

  (* [paths m pass via] means that we already performed [pass-1] steps
     of the main loop, and, in step [pass], we already processed edges
     in [via] *)
  predicate paths (m: distmap) (pass: int) (via: set (vertex, vertex)) =
    forall v: vertex. mem v vertices ->
    match m[v] with
      | Finite n ->
        not negcycle ->
        (exists d: int. 0 <= d < pass /\ shortest_path s v n d) \/
        (forall n': int. shortest_path s v n' pass ->
          (exists u: vertex. mem (u, v) edges /\
          shortest_path s u (n' - weight u v) (pass - 1)) /\
          (forall u: vertex. mem (u, v) edges ->
          shortest_path s u (n' - weight u v) (pass - 1) ->
          mem (u, v) via -> n = n'))
      | Infinite ->
        (forall d: int. 0 <= d < pass ->
          forall n: int. not (path s v n d)) /\
        (forall u: vertex. mem (u, v) via ->
          forall d: int. 0 <= d < pass ->
          forall n: int. not (path s u n d))
    end

  lemma paths_no_path:
    forall m: distmap, p: int, v: set (vertex, vertex). paths m p v ->
    forall v: vertex. mem v vertices ->
    (no_path s v -> m[v] = Infinite)

  lemma paths_next:
    forall m: distmap, d: int. 0 <= d < cardinal vertices ->
    paths m d edges -> paths m (d + 1) empty

  let relax (m: ref distmap) (u v: vertex) (pass: int)
            (via: set (vertex, vertex)) =
    { mem (u, v) edges /\ not (mem (u, v) via) /\ paths !m pass via }
    let n = !m[u] ++ Finite (weight u v) in
    if n << !m[v] then m := !m[v <- n]
    { paths !m pass (add (u, v) via) }

  exception NegativeCycle (* list vertex *)

  let bellman_ford () =
    { }
    let m = ref (initialize_single_source s) in
    for i = 1 to cardinal vertices - 1 do
      invariant { paths !m i empty }

      let es = ref edges in
      let es_co = ref empty in
      while not (Bag.is_empty es) do
        invariant { paths !m i !es_co /\
          union !es !es_co = edges /\ inter !es !es_co = empty }
        variant { cardinal !es }

        let (u, v) = Bag.pop es in
        assert { not (mem (u, v) !es_co) };
        relax m u v i !es_co;
        es_co := add (u, v) !es_co
      done;

      assert { !es_co = edges };
      assert { paths !m i edges }
    done;

    let e = ref edges in
    while not (Bag.is_empty e) do
      variant { cardinal !e }

      let (u, v) = Bag.pop e in

      if (!m[v]) << (!m[u] ++ (Finite (weight u v))) then
        raise NegativeCycle
    done;

    assert {
      paths !m (cardinal vertices) empty /\
      (forall v: vertex. mem v vertices ->
        (no_path s v -> !m[v] = Infinite) /\
        (forall n d: int. shortest_path s v n d -> !m[v] = Finite n))
    };

    !m

    { not negcycle /\
      forall v: vertex. mem v vertices ->
      match result[v] with
        | Infinite -> no_path s v
        | Finite n -> exists d: int. shortest_path s v n d
       end }
    | NegativeCycle -> { negcycle }

end

(*
Local Variables:
compile-command: "why3ide bf.mlw"
End:
*)
