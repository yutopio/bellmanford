
(* Proof of Bellman-Ford algorithm *)

theory Graph

  use export int.Int
  use export set.Fset

  type vertex
  constant vertices : set vertex
  constant edges: set (vertex, vertex)
  constant s : vertex
  function weight vertex vertex : int

  axiom s_in_graph: mem s vertices

  axiom edges_def:
    forall x y: vertex. mem (x, y) edges ->
    (mem x vertices /\ mem y vertices)

  inductive path (v1 v2: vertex) (n: int) =
    | path_empty:
        forall v: vertex. path v v 0
    | path_succ:
        forall v1 v2 v3: vertex, n: int. path v1 v2 n ->
        mem (v2, v3) edges -> path v1 v3 (n + (weight v2 v3))

  inductive reachable (v: vertex) (d: int) =
    | reachable_empty:
        forall v: vertex. reachable s 0
    | reachable_succ:
        forall v1 v2: vertex, d: int. reachable v1 d ->
        mem (v1, v2) edges -> reachable v2 (d + 1)

  predicate shortest_path (v1 v2: vertex) (n: int) =
    (path v1 v2 n) /\
    (forall m: int. m < n -> not (path v1 v2 m))

  predicate no_path (v1 v2: vertex) =
    forall n: int. not (path v1 v2 n)

  lemma reach_nonneg:
    forall v: vertex, d: int.
    mem v vertices -> reachable v d -> d >= 0

  lemma reach_source:
    forall v: vertex, n: int.
    mem v vertices -> reachable v 0 -> v = s

  lemma reach_next:
    forall v: vertex, d: int. reachable v (d + 1) ->
    exists u: vertex. mem (u, v) edges /\ reachable u d

  lemma reach_most_n:
    forall v: vertex, d: int. mem v vertices ->
    0 <= d < cardinal vertices ->
    not (reachable v d) -> no_path s v

  predicate negcycle =
    exists v: vertex. mem v vertices /\
    exists n d: int. n < 0 /\ path v v n

end

theory Distance

  use import int.Int

  type dist = Finite int | Infinite

  function (++) (x: dist) (y: dist) : dist =
    match x with
      | Infinite -> Infinite
      | Finite x ->
        match y with
          | Infinite -> Infinite
          | Finite y -> Finite (x + y)
        end
    end

  predicate (<<) (x y: dist) =
    match x with
      | Infinite -> false
      | Finite x ->
        match y with
          | Infinite -> true
          | Finite y -> x < y
        end
    end

  predicate (>>=) (x y: dist) =
    match x with
      | Infinite -> true
      | Finite x ->
        match y with
          | Infinite -> false
          | Finite y -> x >= y
        end
    end

  clone export comparison.MinMax with type t = dist, predicate ge = (>>=)

end

theory FSetTake

  use export set.Fset

  function take (s:set 'a) : 'a

  axiom take_def:
    forall x : set 'a. not (is_empty x) ->
    mem (take x) x

end

(* a bag is simply a reference containing a finite set *)
module Bag

  use export FSetTake
  use export module ref.Ref

  type bag 'a = ref (set 'a)

  let is_empty (b: bag 'a) =
    {} is_empty !b { result=True <-> is_empty !b }

  (*
  val push (x: 'a) (b: bag 'a) :
    {} unit writes b { !b = add x (old !b) }
  *)

  let pop (b: bag 'a) =
    { not (is_empty !b) }
    let x = take !b in
    b := remove x !b;
    x
    { mem result (old !b) /\ !b = remove result (old !b) }

end

module BellmanFord

  use import int.MinMax
  use import map.Map
  use import module ref.Ref
  use import Graph
  use import Distance
  use module Bag

  type distmap = map vertex dist

  function initialize_single_source (s: vertex) : distmap =
    (const Infinite)[s <- Finite 0]

  predicate paths (m: distmap) (pass: int) (via: set (vertex, vertex)) =
    forall v: vertex. mem v vertices ->
    match m[v] with
      | Finite n -> path s v n
      | Infinite ->
        (forall d: int. 0 <= d < pass -> not (reachable v d)) /\
        (forall u: vertex. mem (u, v) via ->
        forall d: int. 0 <= d < pass -> not (reachable u d))
    end /\
    ((no_path s v) -> m[v] = Infinite)

  lemma paths_subset:
    forall m: distmap, p: int, k: set (vertex, vertex).
    paths m p k -> paths m p empty

  let relax (m: ref distmap) (u: vertex) (v: vertex) (pass: int) =
    { exists w: int. mem (u, v) edges /\ paths !m pass empty }
    let d = !m[u] ++ Finite (weight u v) in
    if d << !m[v] then m := !m[v <- d]
    { paths !m pass empty /\
      (get (old !m) v >>= get !m v) /\
      forall x: vertex. (x <> v -> get !m x = get (old !m) x) }

  exception NegativeCycle (* list vertex *)

  let bellman_ford () =
    { }
    let m = ref (initialize_single_source s) in
    assert { paths !m 1 empty };

    for i = 1 to cardinal vertices - 1 do
      invariant { paths !m i empty }

      let e = ref edges in
      while not (Bag.is_empty e) do
        invariant { subset !e edges /\ paths !m i (diff edges !e) }
        variant { cardinal !e }
        let (u, v) = Bag.pop e in
        relax m u v i
      done
    done;

    let e = ref edges in
    while not (Bag.is_empty e) do
      variant { cardinal !e }

      let (u, v) = Bag.pop e in

      if (get !m v) <<
        ((get !m u) ++ (Finite (weight u v))) then
        raise NegativeCycle
    done;

    !m

    { paths result (cardinal vertices) empty }
    | NegativeCycle -> { }

end

(*
Local Variables:
compile-command: "why3ide bf.mlw"
End:
*)
