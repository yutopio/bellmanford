
(* Proof of Bellman-Ford algorithm *)

theory Graph

  use export int.Int
  use export set.Fset
  use export list.List
  use list.Mem
  use export list.Append
  use export list.Length

  type vertex
  constant vertices : set vertex
  constant edges: set (vertex, vertex)
  constant s : vertex
  function weight vertex vertex : int

  axiom s_in_graph: mem s vertices
  lemma vertices_cardinal_pos: cardinal vertices > 0

  axiom edges_def:
    forall x y: vertex. mem (x, y) edges ->
    (x <> y /\ mem x vertices /\ mem y vertices)

  inductive path (s: vertex) (l: list vertex) =
    | path_empty:
        forall v: vertex. mem v vertices -> path v (Cons v Nil)
    | path_succ:
        forall s v1: vertex, l: list vertex. path s (Cons v1 l) ->
        forall v2: vertex. mem (v1, v2) edges ->
        path s (Cons v2 (Cons v1 l))

  function last (l: list vertex) : vertex =
    match l with
    | Nil -> s (* Not happen. I want assert. *)
    | Cons x Nil -> x
    | Cons _ rest -> last rest
    end

  function sum (l: list vertex) : int =
    match l with
    | Nil -> 0 (* Not happen. I want assert... *)
    | Cons v2 rest ->
      match rest with
      | Nil -> 0
      | Cons v1 _ -> (weight v1 v2) + (sum rest)
      end
    end

  lemma path_last_elem_equal:
    forall s: vertex, l: list vertex. path s l -> last l = s

  lemma path_in_vertices:
    forall s: vertex, l: list vertex. path s l ->
    forall v: vertex. Mem.mem v l -> mem v vertices

  lemma path_pred_existence:
    forall s v: vertex, l: list vertex. path s (Cons v l) ->
    l <> Nil -> path s l

  predicate shortest_path_depth (s: vertex) (l: list vertex) (d: int) =
    match l with
    | Nil -> false
    | Cons t _ -> path s l /\
      forall l': list vertex. length l' < d -> path s (Cons t l') ->
      sum (Cons t l') >= sum l
    end

  predicate shortest_path (s: vertex) (l: list vertex) =
    match l with
    | Nil -> false
    | Cons t _ -> path s l /\
      forall l': list vertex. path s (Cons t l') ->
      sum (Cons t l') >= sum l
    end

  predicate no_path (s v: vertex) =
    forall s v: vertex, l: list vertex. not (path s (Cons v l))

  lemma path_merge:
    forall s1 s2: vertex, l1 l2: list vertex.
    path s1 (Cons s2 l1) -> path s2 l2 ->
    path s1 (l2 ++ l1)

  lemma path_split:
    forall s1 s2: vertex, l1 l2: list vertex.
    path s1 (l2 ++ (Cons s2 l1)) ->
    path s1 (Cons s2 l1) /\ path s2 (l2 ++ (Cons s2 Nil))

  lemma reach_less_than_n:
    forall s: vertex. mem s vertices ->
    forall v: vertex, l: list vertex. path s (Cons v l) ->
    exists l': list vertex. length l' < cardinal vertices /\
      path s (Cons v l')

  lemma reach_most_n:
    forall s v: vertex. mem s vertices /\ mem v vertices ->
    (forall l: list vertex. length l < cardinal vertices ->
      not (path s (Cons v l))) ->
    no_path s v

  predicate negcycle =
    exists v: vertex. mem v vertices /\
    exists l: list vertex. length l > 0 /\ path v (Cons v l) /\
      sum (Cons v l) < 0

  (*** Later we will eliminate this assumption ***)
  axiom ignore_negcycle: negcycle -> false

  (* Shortest path distance is uniquely determined if exists. *)
  lemma shortest_path_unique_distance:
    forall s v: vertex, l: list vertex. shortest_path s (Cons v l) ->
    forall l': list vertex. length (Cons v l) <> length (Cons v l') ->
    not (shortest_path s (Cons v l'))

  (* Needs to prove completeness *)
  lemma no_path_xor_shortest_path_exists:
    not negcycle -> forall v: vertex. mem v vertices ->
    (no_path s v <->
      not (exists l: list vertex. shortest_path s (Cons v l)))

end

theory Distance

  use import int.Int

  type dist = Finite int | Infinite

  function (++) (x: dist) (y: dist) : dist =
    match x with
      | Infinite -> Infinite
      | Finite x ->
        match y with
          | Infinite -> Infinite
          | Finite y -> Finite (x + y)
        end
    end

  predicate (<<) (x y: dist) =
    match x with
      | Infinite -> false
      | Finite x ->
        match y with
          | Infinite -> true
          | Finite y -> x < y
        end
    end

  predicate (>>=) (x y: dist) =
    match x with
      | Infinite -> true
      | Finite x ->
        match y with
          | Infinite -> false
          | Finite y -> x >= y
        end
    end

  clone export comparison.MinMax with type t = dist, predicate ge = (>>=)

end

theory FSetEx

  use export set.Fset

  function take (s:set 'a) : 'a

  axiom take_def:
    forall x : set 'a. not (is_empty x) ->
    mem (take x) x

  lemma set_empty:
    forall a: set 'a. is_empty a <-> a = empty

  lemma set_union_exchange:
    forall a b: set 'a. union a b = union b a

  lemma set_inter_exchange:
    forall a b: set 'a. inter a b = inter b a

  lemma set_inter_choice:
    forall a b: set 'a, e: 'a. inter a b = empty ->
    mem e a -> not (mem e b)

  lemma set_preserve_union:
    forall a b: set 'a, e: 'a. mem e a ->
    union (remove e a) (add e b) = union a b

  lemma set_preserve_inter:
    forall a b: set 'a, e: 'a. mem e a /\ not (mem e b) ->
    inter (remove e a) (add e b) = inter a b

  lemma set_empty_union:
    forall a: set 'a. union a empty = a

  lemma set_empty_inter:
    forall a: set 'a. inter a empty = empty

end

(* a bag is simply a reference containing a finite set *)
module Bag

  use export FSetEx
  use export module ref.Ref

  type bag 'a = ref (set 'a)

  let is_empty (b: bag 'a) =
    {} is_empty !b { result=True <-> is_empty !b }

  (*
  val push (x: 'a) (b: bag 'a) :
    {} unit writes b { !b = add x (old !b) }
  *)

  let pop (b: bag 'a) =
    { not (is_empty !b) }
    let x = take !b in
    b := remove x !b;
    x
    { mem result (old !b) /\ !b = remove result (old !b) }

end

module BellmanFord

  use import int.MinMax
  use import map.Map
  use import module ref.Ref
  use import Graph
  use import Distance
  use FSetEx
  use module Bag

  type distmap = map vertex dist

  function initialize_single_source (s: vertex) : distmap =
    (const Infinite)[s <- Finite 0]

  (* [inv1 m pass via] means that we already performed [pass-1] steps
     of the main loop, and, in step [pass], we already processed edges
     in [via] *)
  predicate inv1 (m: distmap) (pass: int) (via: set (vertex, vertex)) =
    forall v: vertex. mem v vertices ->
    match m[v] with
    | Finite n ->
      (exists l: list vertex. length l < pass /\
        path s (Cons v l) /\ sum (Cons v l) = n) /\
      (forall l: list vertex. length l < pass ->
        path s (Cons v l) -> sum (Cons v l) >= n) /\
      (forall u: vertex. mem (u, v) via ->
        forall l: list vertex. length l < pass ->
        path s (Cons u l) -> sum (Cons u l) >= n - weight u v)
    | Infinite ->
      (forall l: list vertex. length l < pass ->
        not (path s (Cons v l))) /\
      (forall u: vertex. mem (u, v) via ->
        forall l: list vertex. length l < pass ->
          not (path s (Cons u l)))
    end

  predicate inv2 (m: distmap) (via: set (vertex, vertex)) =
    forall v: vertex. mem v vertices ->
    match m[v] with
    | Finite n ->
      forall u: vertex. mem (u, v) via ->
        forall l: list vertex.
        path s (Cons u l) -> sum (Cons u l) >= n - weight u v
    | Infinite -> true
    end

  lemma inv1_next:
    forall m: distmap, d: int. 0 <= d < cardinal vertices ->
    inv1 m d edges -> inv1 m (d + 1) empty
(*
  lemma inv2_shortest:
    forall v: vertex. mem v vertices -> forall n: int.
    (exists d: int. 0 <= d < cardinal vertices /\ path s v n d) /\
    (forall d': int. 0 <= d' < cardinal vertices ->
      forall n': int. path s v n' d' -> n <= n') /\
    (forall n' d': int. path_ends_with s v n' d' edges -> n <= n') ->
    exists d: int. shortest_path s v n d
*)
  let relax (m: ref distmap) (u v: vertex) (pass: int)
            (via: set (vertex, vertex)) =
    { mem (u, v) edges /\ not (mem (u, v) via) /\ inv1 !m pass via }
    let n = !m[u] ++ Finite (weight u v) in
    if n << !m[v] then m := !m[v <- n]
    { inv1 !m pass (add (u, v) via) }

  exception NegativeCycle (* list vertex *)

  let bellman_ford () =
    { }
    let m = ref (initialize_single_source s) in

    for i = 1 to cardinal vertices - 1 do
      invariant { inv1 !m i empty }

      let es = ref edges in
      let es_co = ref empty in
      while not (Bag.is_empty es) do
        invariant { inv1 !m i !es_co /\
          union !es !es_co == edges /\ inter !es !es_co == empty }
        variant { cardinal !es }

        let (u, v) = Bag.pop es in
        relax m u v i !es_co;
        es_co := add (u, v) !es_co
      done
    done;

    let es = ref edges in
    let es_co = ref empty in
    while not (Bag.is_empty es) do
      invariant { inv2 !m !es_co /\
          union !es !es_co == edges /\ inter !es !es_co == empty }
      variant { cardinal !es }

      let (u, v) = Bag.pop es in
      if (!m[u] ++ (Finite (weight u v))) << (!m[v]) then (
        assert {
          match !m[v] with
          | Infinite -> false
          | Finite dv ->
            match !m[u] with
            | Infinite -> false
            | Finite du ->
              (exists l: list vertex. sum (Cons u l) = du /\
                shortest_path_depth s (Cons u l) (cardinal vertices)) /\
              (exists l: list vertex. sum (Cons v l) = dv /\
                shortest_path_depth s (Cons v l) (cardinal vertices)) /\
              (forall l: list vertex. sum (Cons v l) = dv /\
                not (shortest_path_depth s (Cons v l)
                  (cardinal vertices + 1)))
            end
          end
        };
        raise NegativeCycle)
      else ();
      es_co := add (u, v) !es_co
    done;

    assert { inv1 !m (cardinal vertices) empty };
    assert { inv2 !m edges };

    !m

    { forall v: vertex. mem v vertices ->
      match result[v] with
        | Finite n -> exists l: list vertex. shortest_path s (Cons v l)
        | Infinite -> no_path s v
      end }
    | NegativeCycle ->
    { exists v: vertex. mem v vertices /\
      exists l: list vertex. length l > 0 /\ path v (Cons v l) /\
        sum (Cons v l) < 0 }
end

(*
Local Variables:
compile-command: "why3ide bf.mlw"
End:
*)
